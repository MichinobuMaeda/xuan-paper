/**
 * @vitest-environment jsdom
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { hslToHex, isDarkBackground, downloadFile } from '../../src/utils.js';

// Mock DOM APIs for downloadFile
const mockCreateObjectURL = vi.fn();
const mockRevokeObjectURL = vi.fn();
const mockClick = vi.fn();
const mockAppendChild = vi.fn();
const mockRemoveChild = vi.fn();

// Setup DOM mocks
Object.defineProperty(globalThis, 'URL', {
  value: {
    createObjectURL: mockCreateObjectURL,
    revokeObjectURL: mockRevokeObjectURL,
  },
  writable: true,
});

Object.defineProperty(globalThis, 'Blob', {
  value: vi.fn().mockImplementation(function(content) {
    this.content = content;
  }),
  writable: true,
});

// Mock document
const mockDocument = {
  createElement: vi.fn(),
  body: {
    appendChild: mockAppendChild,
  },
};

Object.defineProperty(globalThis, 'document', {
  value: mockDocument,
  writable: true,
});

describe('utils.js', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Reset mock implementations
    mockCreateObjectURL.mockReturnValue('blob:mock-url');
    globalThis.Blob.mockImplementation(function(content) {
      this.content = content;
    });
    mockDocument.createElement.mockReturnValue({
      click: mockClick,
      setAttribute: vi.fn(),
      parentNode: {
        removeChild: mockRemoveChild,
      },
    });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('hslToHex', () => {
    it('should convert HSL to hex with default saturation and lightness', () => {
      // Test pure red (0°)
      expect(hslToHex(0)).toBe('#ff0000');
      
      // Test pure green (120°)
      expect(hslToHex(120)).toBe('#00ff00');
      
      // Test pure blue (240°)
      expect(hslToHex(240)).toBe('#0000ff');
    });

    it('should convert HSL to hex with custom saturation and lightness', () => {
      // Test red with 50% saturation and 75% lightness
      const result = hslToHex(0, 50, 75);
      expect(result).toMatch(/^#[0-9a-f]{6}$/);
      expect(result).toBe('#df9f9f');
    });

    it('should handle edge cases', () => {
      // Test with 0% saturation (grayscale)
      expect(hslToHex(0, 0, 50)).toBe('#808080');
      
      // Test with 0% lightness (black)
      expect(hslToHex(0, 100, 0)).toBe('#000000');
      
      // Test with 100% lightness (white)
      expect(hslToHex(0, 100, 100)).toBe('#ffffff');
    });

    it('should handle hue values beyond 360 degrees', () => {
      // Hue wraps around, so 360° should be same as 0°
      expect(hslToHex(360)).toBe(hslToHex(0));
      
      // 480° should be same as 120°
      expect(hslToHex(480)).toBe(hslToHex(120));
    });

    it('should produce valid hex color format', () => {
      const colors = [
        hslToHex(30, 80, 60),
        hslToHex(150, 40, 30),
        hslToHex(270, 90, 80),
      ];
      
      colors.forEach(color => {
        expect(color).toMatch(/^#[0-9a-f]{6}$/);
        expect(color).toHaveLength(7);
      });
    });
  });

  describe('isDarkBackground', () => {
    it('should identify dark colors correctly', () => {
      // Test common dark colors
      expect(isDarkBackground('#000000')).toBe(true); // Black
      expect(isDarkBackground('#1a1a1a')).toBe(true); // Very dark gray
      expect(isDarkBackground('#333333')).toBe(true); // Dark gray
      expect(isDarkBackground('#1976d2')).toBe(true); // Material blue
      expect(isDarkBackground('#d32f2f')).toBe(true); // Material red
    });

    it('should identify light colors correctly', () => {
      // Test common light colors
      expect(isDarkBackground('#ffffff')).toBe(false); // White
      expect(isDarkBackground('#f5f5f5')).toBe(false); // Light gray
      expect(isDarkBackground('#ffeb3b')).toBe(false); // Material yellow
      expect(isDarkBackground('#4caf50')).toBe(false); // Material green
      expect(isDarkBackground('#ff9800')).toBe(false); // Material orange
    });

    it('should handle edge cases around the threshold', () => {
      // Test colors near the boundary
      const borderlineDark = '#666666';
      const borderlineLight = '#999999';
      
      // These should have consistent behavior
      expect(typeof isDarkBackground(borderlineDark)).toBe('boolean');
      expect(typeof isDarkBackground(borderlineLight)).toBe('boolean');
    });

    it('should handle different hex formats', () => {
      // Test with uppercase hex
      expect(isDarkBackground('#FF0000')).toBe(true);
      expect(isDarkBackground('#FFFFFF')).toBe(false);
      
      // Test with mixed case
      expect(isDarkBackground('#Ff0000')).toBe(true);
      expect(isDarkBackground('#FfFfFf')).toBe(false);
    });

    it('should work with colors generated by hslToHex', () => {
      // Test integration with hslToHex function
      const darkColor = hslToHex(240, 100, 30); // Dark blue
      const lightColor = hslToHex(60, 100, 80);  // Light yellow
      
      expect(isDarkBackground(darkColor)).toBe(true);
      expect(isDarkBackground(lightColor)).toBe(false);
    });
  });

  describe('downloadFile', () => {
    it('should create and trigger download for text content', () => {
      const filename = 'test.txt';
      const content = 'Hello, World!';
      
      downloadFile(filename, content);
      
      // Verify Blob creation
      expect(globalThis.Blob).toHaveBeenCalledWith([content]);
      
      // Verify URL creation
      expect(mockCreateObjectURL).toHaveBeenCalledWith(expect.any(Object));
      
      // Verify link element creation and setup
      expect(mockDocument.createElement).toHaveBeenCalledWith('a');
      
      // Verify link was clicked and cleaned up
      expect(mockClick).toHaveBeenCalled();
      expect(mockAppendChild).toHaveBeenCalled();
      expect(mockRemoveChild).toHaveBeenCalled();
    });

    it('should handle different file types', () => {
      const testCases = [
        { filename: 'data.json', content: '{"key": "value"}' },
        { filename: 'script.js', content: 'console.log("test");' },
        { filename: 'style.css', content: 'body { margin: 0; }' },
        { filename: 'document.html', content: '<html><body>Test</body></html>' },
      ];
      
      testCases.forEach(({ filename, content }) => {
        vi.clearAllMocks();
        
        downloadFile(filename, content);
        
        expect(globalThis.Blob).toHaveBeenCalledWith([content]);
        expect(mockClick).toHaveBeenCalled();
      });
    });

    it('should set correct download attribute', () => {
      const mockSetAttribute = vi.fn();
      const mockLink = {
        click: mockClick,
        setAttribute: mockSetAttribute,
        parentNode: {
          removeChild: mockRemoveChild,
        },
      };
      
      mockDocument.createElement.mockReturnValue(mockLink);
      
      const filename = 'download.txt';
      const content = 'test content';
      
      downloadFile(filename, content);
      
      expect(mockSetAttribute).toHaveBeenCalledWith('download', filename);
    });

    it('should handle empty content', () => {
      const filename = 'empty.txt';
      const content = '';
      
      downloadFile(filename, content);
      
      expect(globalThis.Blob).toHaveBeenCalledWith(['']);
      expect(mockClick).toHaveBeenCalled();
    });

    it('should handle binary content', () => {
      const filename = 'binary.bin';
      const content = new ArrayBuffer(8);
      
      downloadFile(filename, content);
      
      expect(globalThis.Blob).toHaveBeenCalledWith([content]);
      expect(mockClick).toHaveBeenCalled();
    });

    it('should clean up DOM elements after download', () => {
      const mockLink = {
        click: mockClick,
        setAttribute: vi.fn(),
        parentNode: {
          removeChild: mockRemoveChild,
        },
      };
      
      mockDocument.createElement.mockReturnValue(mockLink);
      
      downloadFile('test.txt', 'content');
      
      // Verify the link was added to DOM and then removed
      expect(mockAppendChild).toHaveBeenCalledWith(mockLink);
      expect(mockRemoveChild).toHaveBeenCalledWith(mockLink);
    });
  });

  describe('integration tests', () => {
    it('should work with color conversion and dark background detection', () => {
      // Test a complete color workflow
      const hue = 210; // Blue
      const saturation = 100;
      const lightness = 25; // Dark
      
      const hexColor = hslToHex(hue, saturation, lightness);
      const isDark = isDarkBackground(hexColor);
      
      expect(hexColor).toMatch(/^#[0-9a-f]{6}$/);
      expect(isDark).toBe(true);
    });

    it('should handle color-based file generation', () => {
      // Simulate generating a CSS file with color values
      const colors = [
        { name: 'primary', h: 210, s: 100, l: 50 },
        { name: 'secondary', h: 45, s: 100, l: 60 },
      ];
      
      const cssContent = colors.map(color => {
        const hex = hslToHex(color.h, color.s, color.l);
        const textColor = isDarkBackground(hex) ? '#ffffff' : '#000000';
        return `.${color.name} { background-color: ${hex}; color: ${textColor}; }`;
      }).join('\\n');
      
      downloadFile('colors.css', cssContent);
      
      expect(globalThis.Blob).toHaveBeenCalledWith([cssContent]);
      expect(mockClick).toHaveBeenCalled();
    });
  });
});
